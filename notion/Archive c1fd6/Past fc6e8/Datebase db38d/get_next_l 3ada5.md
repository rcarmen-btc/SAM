# get_next_line

Created time: November 17, 2020 10:00 PM
Days ago: 504
Deadline: January 28, 2021 12:00 AM
Grade: 100
Left: -433 day(s) -9.3 hour(s) 
Orbit: #1
Status: Complited
Subject: en.subject.gnl.pdf
Tags: C, Project

[Tasks](get_next_l%203ada5/Tasks%20ebfcb.csv)

## Конспект

Возвращаемые значения:

1 - \n

0 - EOF 

Цель этого проекта состоит в том, чтобы заставить вас закодировать функцию, которая возвращает строку, заканчивающуюся новой строкой, считанную из файлового дескриптора.

Этот проект не только позволит вам добавить очень удобную функцию в вашу коллекцию, но и позволит вам изучить очень интересную новую концепцию программирования на языке Си: статические переменные

- Ваш проект должен быть написан в соответствии с нормой. Если у вас есть бонусные файлы/функции, они включены в проверку нормы, и вы получите 0, если внутри есть ошибка нормы.
- Ваши функции не должны завершаться неожиданно (ошибка сегментации, ошибка шины, двойная свобода и т. д.), Кроме неопределенного поведения. Если это произойдет, ваш проект будет считаться нефункциональным и получит 0 баллов во время оценки.
- Все выделенное кучи пространство памяти должно быть должным образом освобождено, когда это необходимо. Никакие утечки не будут допущены.
- Если субъект требует этого, вы должны отправить Makefile, который скомпилирует ваши исходные файлы в требуемый вывод с флагами-Wall,- Wextra и-Werror, и ваш Makefile не должен повторно связываться.
- Ваш Makefile должен, по крайней мере, содержать правила $(NAME), all, clean, fclean и re.
- Чтобы включить бонусы в свой проект, вы должны включить бонус правил в свой Makefile, который добавит все различные заголовки, библиотеки или функции, запрещенные в основной части проекта. Бонусы должны быть в другом файле _bonus.{c/h}. Обязательная и бонусная части оценки проводятся отдельно.
- Если ваш проект позволяет вам использовать ваш libft, вы должны скопировать его исходные файлы и связанный с ними Makefile в папку libft вместе с соответствующим Makefile. Makefile вашего проекта должен скомпилировать библиотеку с помощью ее Makefile, а затем скомпилировать проект.
- Мы рекомендуем вам создавать тестовые программы для вашего проекта, даже если эта работа не будет представлена и не будет оценена. Это даст вам возможность легко проверить свою работу и работу ваших коллег. Вы найдете эти тесты особенно полезными во время вашей защиты. Действительно, во время защиты вы можете свободно использовать свои тесты и/или тесты оцениваемого вами сверстника.
- Отправляйте свою работу в назначенный вам репозиторий git. Оцениваться будет только работа в репозитории git. Если Deepthought назначается для оценки вашей работы, это будет сделано после вашей экспертной оценки. Если во время оценки Deepthought произойдет ошибка в каком-либо разделе вашей работы, оценка прекратится.
- Вызов вашей функции get_next_line в цикле позволит вам читать текст, доступный в файловом дескрипторе, по одной строке за раз до тех пор, пока EOF.
- Убедитесь, что ваша функция ведет себя хорошо, когда она читает из файла и когда она читает из стандартного ввода.
- libft не допускается для данного проекта. Вы должны добавить файл get_next_line_utils.c, который будет содержать функции, необходимые для работы вашей get_next_line.
- Ваша программа должна компилироваться с флагом-D BUFFER_SIZE=xx. который будет использоваться в качестве размера буфера для вызовов чтения в вашей get_next_line. Это значение будет изменено вашими оценщиками и компанией moulinette.
- Компиляция будет выполняться следующим образом : gcc -Wall -Wextra -Werror -D BUFFER_SIZE=32 get_next_line.c get_next_line_utils.c
- Ваше чтение должно использовать BUFFER_SIZE, определенный во время компиляции, для чтения из файла или из stdin.
- В заголовочном файле get_next_line.ч вы, должно быть, по крайней мере, прототип
get_next_line функции.

Работает ли ваша функция по-прежнему, если значение BUFFER_SIZE равно 9999? А если значение BUFFER_SIZE равно 1? А 10000000? И знаете почему?

Вы должны стараться читать как можно меньше каждый раз, когда вызывается get_next_line. Если вы столкнулись с новой строкой, вы должны вернуть текущую строку. Не читайте весь файл, а затем обрабатывайте каждую строку.

Не сдавайте свой проект без тестирования. Есть много тестов, чтобы запустить, покрыть свои базы. Попробуйте прочитать из файла, из перенаправления, из стандартного ввода. Как ведет себя ваша программа, когда вы отправляете новую строку в стандартный вывод? А CTRL-D?

- Мы считаем, что get_next_line имеет неопределенное поведение, если между двумя вызовами один и тот же файловый дескриптор переключается на другой файл до того, как EOF был достигнут на первом fd.
- lseek не является разрешенной функцией. Чтение файла должно быть сделано только один раз.
- Наконец, мы считаем, что get_next_line имеет неопределенное поведение при чтении из двоичного файла. Однако, если вы хотите, вы можете сделать это поведение последовательным.
- Глобальные переменные запрещены.

Хорошим началом было бы узнать, что такое статическая переменная:
[https://en.wikipedia.org/wiki/Static_variable](https://en.wikipedia.org/wiki/Static_variable)